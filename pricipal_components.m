%clear and load data
clear
clc
data = xlsread('principalcomponents.xls');
data = data(:,sum(isnan(data))==0);

%Run principal componenets
%eigenvect is the matrix of eigenvectors`
%princ_score is matrix with pricipal component scores
%eigen_val is the vector of eigenvalues
[eigenvect,prin_score,eigenval] = princomp(data);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%If we needed to use Connor Korajczyk's procedure, then instead of the
%using princomp on the orginal data, we would want to use the pcacov
%function on the return cross product matrix data' * data and then project
%the eigenvectors as done in the minimum variance tutorial
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%The eigen values and vectors are alread sorted in descending sequence
%We want to identify the most important components, which are generally
%the ones with eigenvalues greater than 1 if we use the correlation matrix
%as an input, or determine a percentage of total var explained if we
%used the covariance matrix as an input

%set cut off and find cummulative % explained by principal components
cut_off = .75;

explained = eigenval./sum(eigenval);
cum_expl = cumsum(explained);

%how many components do we need to explain 75%?
%num_comp = length(cum_expl(cum_expl(:) <= cut_off)) + 1;
num_comp = 20;
%create approximate return process using top principal components
[r c] = size(data);
approx = prin_score(:,1:num_comp) * eigenvect(:,1:num_comp)';

%let's just take a quick look at how well our approximated return series
%correlates with the orginal
test_rho = [corr(approx(:,1),data(:,1)) corr(approx(:,35),data(:,35)) corr(approx(:,60),data(:,60))];
fprintf('Correlation for assets 1,35,and 60 are %1.2f,%1.2f,%1.2f \n',test_rho(1), test_rho(2), test_rho(3));

%Identify Var-Cov matrix generated by the top n principal components
%notice that since the model of returns is E[R] = a + bf + e, we need 
%to add the diagonal matrix of residual variances
[rows, columns] = size(approx);
ee = (data - approx)' * (data - approx);    
approx_cov = approx' * approx + diag(diag(ee));


%Create Factor mimicking portfolios
%We will start with the portfolio approach to creating the mimicking
%portfolio by sorting based on the factor loadings, and then creating a
%long-short portfolio where we are long the assets with the highest
%loadings on that factor and short the ones with the lowest

%let's start with just the first principal component
%the loadings for each of the stocks on the first PC are in the first
%column of the eigenvec matrix
[loadings, positions] = sort(eigenvect(:,1),'descend');

long_assets = sort(positions(1:round(columns/10)));
short_assets = sort(positions(round(columns*(9/10)):end));

%mimicking portfolio returns based on orginal data, the mean(X,dim) finds
%the product of the rows of the matrix X when the dim = 2
long_returns = mean(data(:,long_assets),2);
short_returns = mean(data(:,short_assets),2);

fmr = long_returns - short_returns; %fmr = factor mimic returns

%let's just take a quick look at how well our factor mimicking return
%series correlates with the orginal
test_rhofmr = corr(fmr,prin_score(:,1));
fprintf('Correlation for pc and fmp 1 = %1.2f\n',test_rhofmr);







