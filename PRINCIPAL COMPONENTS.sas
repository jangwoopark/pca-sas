/**********************************************/
/*   READ IN DATA FROM TMP1                   */
/**********************************************/
DATA TEMP;
	SET TMP1.DATA;
RUN;
/**********************************************/
/* GET TRANSPOSE OF RAW RETURNS               */
/**********************************************/
PROC SORT DATA = TEMP; BY DATE; RUN;

PROC TRANSPOSE DATA = TEMP OUT=TEMP_TRANSPOSE (DROP=_LABEL_);
	BY DATE;
RUN;

DATA TEMP_TRANSPOSE;
	SET TEMP_TRANSPOSE;
	IF _NAME_ IN('RET');
	DROP DATE _NAME_;
RUN;

DATA TEMP_TRANSPOSE;
	SET TEMP_TRANSPOSE;
	ARRAY NUM_VARS[*] _NUMERIC_;
	DO I = 1 TO DIM(NUM_VARS);
		IF LEFT(NUM_VARS(I)) IN ('C') THEN NUM_VARS(I) = .; 
	END;
 	DROP I;
RUN;
/**************************************************************/
/* DROP VARIABLES WITH MISSING RETURNS                        */
/* BASED ON MACRO FROM SAS WEBSITE                            */
/**************************************************************/
%LET LENGTH_VAR = 500;
DATA _NULL_;
	SET TEMP_TRANSPOSE END=FINISHED;

	ARRAY NUM_VARS[*] _NUMERIC_; /*LOAD NUMERIC VARS INTO ARRAY*/;
	ARRAY NUM_MISS [&LENGTH_VAR] $ (&LENGTH_VAR*'NON-MISS'); /*CREATE FLAG FOR MISSING, INITIALIZE AS NON-MISS*/

	/* LIST OF VARIABLES TO DROP, MAKE SURE THAT THE LENGTH IS SUFFICIENT*/
	length list $ &LENGTH_VAR; 
	LENGTH KEEP_LIST $ &LENGTH_VAR;

	/* CHECK FOR MISSING VARIABLES  */
	DO I = 1 TO DIM(NUM_VARS);
		IF NUM_VARS(I) EQ . THEN NUM_MISS(I) = 'MISSING';
	END;

	/*CHECK STATUS ON LAST OBSERVATION AND PUT VARS WITH MISSING IN LIST*/
	IF FINISHED THEN DO;
		COUNT = 0;
		DO I = 1 TO DIM(NUM_VARS);
			IF NUM_MISS(I) = 'MISSING' THEN DO;
				LIST = TRIM(LIST)||' '||TRIM(VNAME(NUM_VARS(I)));
				COUNT = COUNT + 1;
			END;

			IF NUM_MISS(I) = 'NON-MISS' THEN KEEP_LIST = TRIM(KEEP_LIST)||' '||TRIM(VNAME(NUM_VARS(I)));
		END;
		CALL SYMPUT('MLIST',LIST);
		CALL SYMPUT('KEEP_LIST',KEEP_LIST); 
		CALL SYMPUT('DIM',LEFT(DIM(NUM_VARS)-COUNT));
	END;

RUN;
/* RENAME VARIABLES SO THEY ARE CONSECUTIVE    */
DATA TEMP_TRANSPOSE;
	SET TEMP_TRANSPOSE (DROP=&MLIST);
RUN;

%MACRO RENAME1(OLDVARLIST, NEWVARLIST);
	%LET K = 1;
	%LET OLD = %SCAN(&OLDVARLIST,&K);
	%LET NEW = %SCAN(&NEWVARLIST, &K);

	%DO %WHILE(("&OLD" NE "") AND ("&NEW" NE ""));
		RENAME &OLD = &NEW;
		%LET K = %EVAL(&K + 1);
		%LET OLD = %SCAN(&OLDVARLIST, &K);
		%LET NEW = %SCAN(&NEWVARLIST, &K);
	%END;
%MEND;

%MACRO CREATE_NAMES;
DATA NEW_VAR_NAMES;
	%DO K = 1 %TO &DIM;
		NEW&K = 1;	
	%END;
RUN;

PROC CONTENTS DATA = NEW_VAR_NAMES NOPRINT OUT = NEW_CONTENTS; RUN;

DATA _NULL_;
	LENGTH NEWVARS $1000;
	RETAIN NEWVARS ' ';
	SET NEW_CONTENTS END = EOF;
	NEWVARS = TRIM(LEFT(NEWVARS))||' '||TRIM(NAME);
	IF EOF THEN CALL SYMPUT('NEWVARLIST',NEWVARS);
RUN;

%PUT &NEWVARLIST;

DATA TEMP_TRANSPOSE;
	SET TEMP_TRANSPOSE;
	%RENAME1(&KEEP_LIST,&NEWVARLIST);
RUN;
	
%MEND CREATE_NAMES;
%CREATE_NAMES;

/***********************************************/
/*  RUN PRINCIPAL COMPONENTS                   */
/***********************************************/
PROC PRINCOMP DATA = TEMP_TRANSPOSE COV OUTSTAT=EIGEN OUT=SCORES NOPRINT;
	VAR NEW1-NEW&DIM;
RUN;

PROC PRINCOMP DATA = TEMP_TRANSPOSE OUTSTAT=EIGEN_CORR OUT=SCORES_CORR NOPRINT;
	VAR NEW1-NEW&DIM;
RUN;

/*******************************************************/
/*  CHOOSE COMPONENTS WITH EIGENVALUES GREATER THAN 1  */
/*******************************************************/
OPTIONS NOMLOGIC NOMPRINT;
%MACRO CHOOSE_PCA;
DATA KEEP_EIGEN;
	SET EIGEN_CORR;
	IF _TYPE_ IN('EIGENVAL','SCORE');
RUN;

DATA KEEP_EIGEN;
	SET KEEP_EIGEN;
	IF _TYPE_ IN('EIGENVAL') THEN DO;
		%DO I = 1 %TO &DIM;
			IF NEW&I > 1 THEN CALL SYMPUT('K',LEFT(&I));
		%END;
	END;
	IF _TYPE_ IN('SCORE');
RUN;

DATA KEEP_EIGEN;
	SET EIGEN (WHERE=(_TYPE_ IN('SCORE')));
	IF _N_ < &K;;
	CALL SYMPUT ('L',LEFT(&K-1));
	DROP _NAME_ _TYPE_;
RUN;

DATA KEEP_SCORES;
	SET SCORES;
	KEEP PRIN1-PRIN&L;
RUN;
%MEND CHOOSE_PCA;
%CHOOSE_PCA;

/**********************************************************/
/* NOW WE USE PROC IML TO CREATE THE COVARIANCE MATRIX    */
/* BASED ON THE TOP K PRINCIPAL COMPONENETS               */
/**********************************************************/
PROC IML;
	USE KEEP_EIGEN;
	READ ALL INTO P;

	USE KEEP_SCORES;
	READ ALL INTO Y;

	APPROX = Y * P; /*NO NEED TO TRANSPOSE OR INVERT AS P IS ALREADY TRANSPOSED*/
	CREATE APPROX FROM APPROX;
	APPEND FROM APPROX;
QUIT;

/****************************************************************/
/* FIND RESIDUALS AND ADD RESIDUAL VARIANCE TO APPROX_CO        */
/****************************************************************/
DATA APPROX;
	SET APPROX;
	ROW = _N_;
RUN;

DATA TEMP_TRANSPOSE;
	SET TEMP_TRANSPOSE;
	ROW = _N_;
RUN;

%MACRO EE;
DATA EE;
	MERGE TEMP_TRANSPOSE APPROX;
	BY ROW;

	%DO K = 1 %TO 70;
		RESIDUAL&K = (NEW&K - COL&K);
	%END;

	KEEP RESIDUAL1-RESIDUAL70;
RUN;
%MEND EE;
%EE;

DATA APPROX;
	SET APPROX;
	DROP ROW;
RUN;

PROC IML;
	USE APPROX;
	READ ALL INTO APPROX;

	USE EE;
	READ ALL INTO EE;

	COV = APPROX` * APPROX + DIAG(EE` * EE);
	B = DIAG(EE` * EE); 
	CREATE COV FROM COV;
	APPEND FROM COV;

	CREATE B FROM B;
	APPEND FROM B;
QUIT;
/****************************************************************/
/*    NOW WE CREATE LONG - SHORT PORTFOLIOS TO MIMIC FIRST      */
/*    PRINCIPAL COMPONENT                                       */
/****************************************************************/
DATA EIGENMATRIX;
	SET EIGEN (WHERE=(_NAME_ IN('Prin1')));
	DROP _TYPE_;
RUN;

PROC TRANSPOSE DATA = EIGENMATRIX OUT=EIGENMATRIX_T;
	BY _NAME_;
	VAR NEW1-NEW&DIM;
RUN;

DATA EIGENMATRIX_T;
	SET EIGENMATRIX_T;
	ASSET = _N_;
RUN;

PROC SORT DATA = EIGENMATRIX_T; BY COL1; RUN;

DATA LONG SHORT;
	SET EIGENMATRIX_T;
	CUM_PER = _N_ / &DIM;
	
	IF CUM_PER >= .9 THEN OUTPUT LONG;
	IF CUM_PER <= .1 THEN OUTPUT SHORT;
	DROP COL1 CUM_PER;
RUN;

/************************************************************/
/*  PUT LIST INTO MACRO VARIABLE TO CHOOSE THE CORRECT FIRM */
/*  RETURNS                                                 */
/************************************************************/
DATA _NULL_;
	LENGTH LONG $1000;
	RETAIN LONG ' ';
	SET LONG END = EOF;

	NEWVAR = 'NEW'||LEFT(ASSET);
	LONG = LEFT(TRIM(LONG))||' '||LEFT(TRIM(NEWVAR));

	IF EOF THEN DO;
		CALL SYMPUTX('LONG',LONG);
	END;
RUN;

DATA _NULL_;
	LENGTH SHORT $1000;
	RETAIN SHORT ' ';
	SET SHORT END = EOF;
	
	NEWVAR = 'NEW'||LEFT(ASSET);
	SHORT = LEFT(TRIM(SHORT))||' '||LEFT(TRIM(NEWVAR));

	IF EOF THEN DO;
		CALL SYMPUTX('SHORT',SHORT);
		PUT SHORT;
	END;
RUN;


DATA LONG;
	SET TEMP_TRANSPOSE (KEEP=&LONG);	
	DATE = _N_;
RUN;

DATA SHORT;
	SET TEMP_TRANSPOSE (KEEP=&SHORT);
	DATE = _N_;
RUN;

PROC TRANSPOSE DATA = LONG OUT=LONG_T;
	BY DATE;
RUN;

PROC TRANSPOSE DATA = SHORT OUT=SHORT_T;
	BY DATE;
RUN;

PROC MEANS DATA = LONG_T NOPRINT;
	BY DATE;
	VAR COL1;
	OUTPUT OUT = LONG_EW (DROP=_TYPE_ _FREQ_) MEAN=LONG;
RUN;

PROC MEANS DATA = SHORT_T NOPRINT;
	BY DATE;
	VAR COL1;
	OUTPUT OUT = SHORT_EW (DROP=_TYPE_ _FREQ_) MEAN=SHORT;
RUN;

DATA MIMIC;
	MERGE SHORT_EW LONG_EW;
	BY DATE;
	LS = LONG - SHORT;
RUN;



